\hypertarget{class_mesh}{}\section{Mesh Class Reference}
\label{class_mesh}\index{Mesh@{Mesh}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_mesh_a2af137f1571af89172b9c102302c416b}{Mesh}} ()
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_aa381581e1c9fe95f438d4a66c4291a5f}{Abaqus\+\_\+\+IO}} (std\+::string \&fname)
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_a69a626f34e07b13615847d2d3028f20b}{Redistribute}} ()
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_mesh_ae30b0028e49c22ae7a6fff0a89db7394}\label{class_mesh_ae30b0028e49c22ae7a6fff0a89db7394}} 
M\+P\+I\+\_\+\+Comm {\bfseries comm}
\item 
\mbox{\Hypertarget{class_mesh_ab4d9d2c7e02931d2d803da95516eaa20}\label{class_mesh_ab4d9d2c7e02931d2d803da95516eaa20}} 
int {\bfseries myid}
\item 
\mbox{\Hypertarget{class_mesh_a8a2f6f435dc9166168d2cda553d833e7}\label{class_mesh_a8a2f6f435dc9166168d2cda553d833e7}} 
int {\bfseries nprocs}
\item 
\mbox{\Hypertarget{class_mesh_ab7f1c680291e263a5b83eec2796b9923}\label{class_mesh_ab7f1c680291e263a5b83eec2796b9923}} 
Petsc\+Int {\bfseries n\+Dims}
\item 
\mbox{\Hypertarget{class_mesh_a1160f45b158032295a5dde423d3b782a}\label{class_mesh_a1160f45b158032295a5dde423d3b782a}} 
Array\+X\+X\+S\+RM {\bfseries Node}
\item 
\mbox{\Hypertarget{class_mesh_ad4f5557e8d2104647a235669f8df09cd}\label{class_mesh_ad4f5557e8d2104647a235669f8df09cd}} 
Array\+X\+X\+I\+RM {\bfseries Element}
\item 
\mbox{\Hypertarget{class_mesh_ae9d1873e57dc7cb666329946c29bbd1b}\label{class_mesh_ae9d1873e57dc7cb666329946c29bbd1b}} 
Array\+XI {\bfseries g\+Elem}
\item 
\mbox{\Hypertarget{class_mesh_a11aa956306c304ccfa37572de291c705}\label{class_mesh_a11aa956306c304ccfa37572de291c705}} 
Array\+XI {\bfseries g\+Node}
\item 
\mbox{\Hypertarget{class_mesh_a1d49421b1ab9aadd6ff11a9caf8de819}\label{class_mesh_a1d49421b1ab9aadd6ff11a9caf8de819}} 
Array\+XI {\bfseries el\+Dist}
\item 
\mbox{\Hypertarget{class_mesh_a6ce034f24bd0d73310649991f5374d13}\label{class_mesh_a6ce034f24bd0d73310649991f5374d13}} 
Array\+XI {\bfseries nd\+Dist}
\item 
\mbox{\Hypertarget{class_mesh_ae1ba84601920b113eba2f99adbaca2d4}\label{class_mesh_ae1ba84601920b113eba2f99adbaca2d4}} 
Petsc\+Int {\bfseries n\+Elem}
\item 
\mbox{\Hypertarget{class_mesh_a2e5ff5315bd999af1361e6afe7a78ed6}\label{class_mesh_a2e5ff5315bd999af1361e6afe7a78ed6}} 
Petsc\+Int {\bfseries n\+Node}
\item 
\mbox{\Hypertarget{class_mesh_af1953886f04ff875c2ca36da8a4f38e2}\label{class_mesh_af1953886f04ff875c2ca36da8a4f38e2}} 
Petsc\+Int {\bfseries n\+Loc\+Elem}
\item 
\mbox{\Hypertarget{class_mesh_a9f1050136cf607064480c079976a6663}\label{class_mesh_a9f1050136cf607064480c079976a6663}} 
Petsc\+Int {\bfseries n\+Loc\+Node}
\item 
\mbox{\Hypertarget{class_mesh_a3f9917990c7eab0ec45e48131737acf1}\label{class_mesh_a3f9917990c7eab0ec45e48131737acf1}} 
Vec {\bfseries U}
\item 
\mbox{\Hypertarget{class_mesh_a7a473f5eda4af43fb9d83873c51f52b0}\label{class_mesh_a7a473f5eda4af43fb9d83873c51f52b0}} 
Vec {\bfseries F}
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_a0ab1f20471ff5deed8803597b979779d}{Reorder\+M\+E\+T\+IS}} (Petsc\+Int nparts=0, Petsc\+Int ncommon\+Nodes=0, Petsc\+Scalar $\ast$tpwgts=N\+U\+LL, Petsc\+Int $\ast$elmwgt=N\+U\+LL, Petsc\+Int $\ast$opts=N\+U\+LL)
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_ab9c61b0cf7cbcb8738d0e904fe532e91}{Reorder\+Par\+M\+E\+T\+IS}} (Petsc\+Int nparts=0, Petsc\+Int ncommon\+Nodes=0, Petsc\+Scalar $\ast$tpwgts=N\+U\+LL, Petsc\+Scalar $\ast$ubvec=N\+U\+LL, Petsc\+Int $\ast$opts=N\+U\+LL, Petsc\+Int ncon=1, Petsc\+Int $\ast$elmwgt=N\+U\+LL, Petsc\+Int wgtflag=0, Petsc\+Int numflag=0)
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_a1c915802d56c4ded24e460e83cfb5399}{Elem\+Dist}} (Eigen\+::\+Array$<$ Petsc\+Int, -\/1, 1 $>$ \&partition)
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_aa6b19f4fdf210f8937694e8c7d30ea15}{Node\+Dist}} ()
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_a1930d80c707de6d202dac7cef0022257}{Expand\+\_\+\+Node}} ()
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_af9e180bd8adb9c495e6c38840ea19f10}{Initialize\+\_\+\+Vectors}} ()
\item 
Petsc\+Error\+Code \mbox{\hyperlink{class_mesh_a54a12376bf99f4f4991af01fc23c9c09}{Localize}} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 21 of file mesh.\+h.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_mesh_a2af137f1571af89172b9c102302c416b}\label{class_mesh_a2af137f1571af89172b9c102302c416b}} 
\index{Mesh@{Mesh}!Mesh@{Mesh}}
\index{Mesh@{Mesh}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Mesh()}{Mesh()}}
{\footnotesize\ttfamily Mesh\+::\+Mesh (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Default constructor 

Definition at line 14 of file mesh.\+cc.


\begin{DoxyCode}
15 \{
16   comm = MPI\_COMM\_WORLD;
17   MPI\_Comm\_rank(comm, &myid);
18   MPI\_Comm\_size(comm, &nprocs);
19 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_mesh_aa381581e1c9fe95f438d4a66c4291a5f}\label{class_mesh_aa381581e1c9fe95f438d4a66c4291a5f}} 
\index{Mesh@{Mesh}!Abaqus\+\_\+\+IO@{Abaqus\+\_\+\+IO}}
\index{Abaqus\+\_\+\+IO@{Abaqus\+\_\+\+IO}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Abaqus\+\_\+\+I\+O()}{Abaqus\_IO()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Abaqus\+\_\+\+IO (\begin{DoxyParamCaption}\item[{std\+::string \&}]{fname }\end{DoxyParamCaption})}

Read in Abaqus mesh 

Definition at line 24 of file mesh.\+cc.


\begin{DoxyCode}
25 \{
26   PetscErrorCode err = 0;
27   \textcolor{keywordflow}{if} (myid == 0)
28   \{
29     std::string s;
30     std::ifstream \_in(fname);
31     \textcolor{keywordflow}{while} (\textcolor{keyword}{true})
32     \{
33       std::getline(\_in,s);
34       \textcolor{comment}{// Convert s to uppercase}
35       std::string upper(s);
36       std::transform(upper.begin(), upper.end(), upper.begin(), ::toupper);
37       \textcolor{comment}{// 0.) Look for the "*Part" Section}
38 \textcolor{comment}{//      if (upper.find("*PART")== static\_cast<std::string::size\_type>(0))}
39 \textcolor{comment}{//      \{}
40 \textcolor{comment}{//        std::cout<<"Find *PART"<<std::endl;}
41 \textcolor{comment}{//      \}}
42       \textcolor{comment}{// 1.) Loop for the "*Nodes" section}
43       \textcolor{keywordflow}{if} (upper.find(\textcolor{stringliteral}{"*NODE"})== \textcolor{keyword}{static\_cast<}std::string::size\_type\textcolor{keyword}{>}(0))
44       \{
45         \textcolor{comment}{//std::string nset\_name = s ;}
46         \textcolor{comment}{//std::cout<<s<<std::endl;}
47         \textcolor{comment}{// Temperatry variables for parsing lines of text}
48         \textcolor{keywordtype}{char} c ;
49         std::string line;
50         \textcolor{keywordtype}{int} i=0;
51         \textcolor{keywordflow}{while} (\_in.peek()!=\textcolor{charliteral}{'*'}&&\_in.peek()!=EOF)
52         \{
53           \textcolor{comment}{// Read an entire line which corresponds to a single points's id and (x,y) value}
54           std::getline(\_in,line);
55           \textcolor{comment}{// Revomie all whitesspaces characters from the line}
56           line.erase(std::remove\_if(line.begin(),line.end(),::isspace),line.end());
57           \textcolor{comment}{// Make a stream out of the modified line so we can stream values from it in the usaly way}
58           std::stringstream ss(line);
59           \textcolor{keywordtype}{int} abaqus\_Node\_id = 0;
60           \textcolor{keywordtype}{double} x = 0 , y = 0;
61           ss >> abaqus\_Node\_id >> c >> x >>c >> y ;
62           Node.conservativeResize(i+1, 2);
63           Node.row(i)<< x , y ;
64           i++;
65         \}
66         \textcolor{comment}{//  std::cout<< Nodes<< "\(\backslash\)n"<< Nodes.rows()<<std::endl;}
67       \}
68       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (upper.find(\textcolor{stringliteral}{"*ELEMENT,"})==\textcolor{keyword}{static\_cast<}std::string::size\_type\textcolor{keyword}{>}(0))
69       \{
70         \textcolor{comment}{//std::string elset\_name = s;}
71         \textcolor{comment}{//std::cout<<s <<std::endl;}
72         \textcolor{keywordtype}{char} c ;
73         std::string line;
74         \textcolor{keywordtype}{int} i = 0;
75         \textcolor{keywordflow}{while} (\_in.peek()!=\textcolor{charliteral}{'*'}&&\_in.peek()!=EOF)
76         \{
77           \textcolor{comment}{// Read an entire line which corresponds to a single Element's id and connectivity value
       (Q4\_only)}
78           std::getline(\_in,line);
79           \textcolor{comment}{// Revomie all whitesspaces characters from the line}
80           line.erase(std::remove\_if(line.begin(),line.end(),::isspace),line.end());
81           \textcolor{comment}{// Make a stream out of the modified line so we can stream values from it in the usaly way}
82           std::stringstream ss(line);
83           \textcolor{keywordtype}{int} abaqus\_el\_id = 0;
84           \textcolor{keywordtype}{int} Node1 =0 , Node2 =0 , Node3 = 0 , Node4 =0;
85           ss >> abaqus\_el\_id >> c >> Node1 >> c >>Node2 >> c >> Node3 >> c >> Node4 ;
86           \textcolor{comment}{// add -1 here becasue we are using a zero Node numbering zero is the first Node}
87           \mbox{\hyperlink{class_element}{Element}}.conservativeResize(i+1, 4);
88           \mbox{\hyperlink{class_element}{Element}}.row(i)<<Node1-1,Node2-1,Node3-1,Node4-1;
89           i++;
90         \}
91       \}
92       \textcolor{keywordflow}{if} (\_in.eof())
93         \textcolor{keywordflow}{break};
94     \}
95 
96     \textcolor{comment}{// Set distribution variables}
97     nLocElem = \mbox{\hyperlink{class_element}{Element}}.rows();
98     nLocNode = Node.rows();
99     elDist.setConstant(nprocs+1, nLocElem);
100     ndDist.setConstant(nprocs+1, nLocNode);
101     elDist(0) = 0;
102     ndDist(0) = 0;
103   \}
104   \textcolor{keywordflow}{else}
105   \{
106     \textcolor{comment}{// Set distribution variables}
107     nLocElem = 0;
108     nLocNode = 0;
109     elDist.resize(nprocs+1);
110     ndDist.resize(nprocs+1);
111   \}
112 
113   \textcolor{comment}{// Distribute Element and Node distribution arrays}
114   err = MPI\_Bcast(elDist.data(), nprocs+1, MPI\_INT, 0, comm);
115   err = MPI\_Bcast(ndDist.data(), nprocs+1, MPI\_INT, 0, comm);
116   nElem = elDist(nprocs);
117   nNode = ndDist(nprocs);
118   nDims = 2; \textcolor{comment}{// TODO generalize this to ND meshes}
119 
120   \textcolor{keywordflow}{return} err;
121 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_mesh_a1c915802d56c4ded24e460e83cfb5399}\label{class_mesh_a1c915802d56c4ded24e460e83cfb5399}} 
\index{Mesh@{Mesh}!Elem\+Dist@{Elem\+Dist}}
\index{Elem\+Dist@{Elem\+Dist}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Elem\+Dist()}{ElemDist()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Elem\+Dist (\begin{DoxyParamCaption}\item[{Eigen\+::\+Array$<$ Petsc\+Int, -\/1, 1 $>$ \&}]{partition }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Redistribute Elements Reallocate Elements Note abbreviations\+: senddisp = first \mbox{\hyperlink{class_element}{Element}} in array sent to each process sendcnt = how many Elements sent to each process -\/ TO BE R\+E\+M\+O\+V\+ED transfer\+Size = how many Elements each process is sending to the other processes recvcnt = how many Elements received from each process recvdsp = beginning location of buffer to receive Elements from each process elmcpy = a copy of \mbox{\hyperlink{class_element}{Element}} reordered for continguous send buffers where = after initial sorting, the local number of each \mbox{\hyperlink{class_element}{Element}} permute = permutation vector for filter matrix (global) 

Definition at line 327 of file mesh.\+cc.


\begin{DoxyCode}
328 \{
329   PetscErrorCode ierr = 0;
339   \textcolor{comment}{// Initialize transfer Variables}
340   \textcolor{keywordtype}{short} elementSize = pow(2,nDims);
341   ArrayXI where = EigLab::gensort(partition).cast<PetscInt>();
342   ArrayXXI transferSize = ArrayXXI::Zero(nprocs,nprocs);
343   ArrayXXIRM elmcpy(\mbox{\hyperlink{class_element}{Element}}.rows(),\mbox{\hyperlink{class_element}{Element}}.cols());
344   \textcolor{keywordflow}{for} (PetscInt i = 0; i < partition.rows(); i++)
345   \{
346     elmcpy.row(i) = \mbox{\hyperlink{class_element}{Element}}.row(where(i));
347     transferSize(partition(i),myid)++;
348   \}
349 
350   \textcolor{comment}{// How many Elements are transferred between each pair of processes}
351   MPI\_Allgather(MPI\_IN\_PLACE, 0, MPIU\_INT, transferSize.data(),
352                 nprocs, MPIU\_INT, comm);
353   Eigen::ArrayXi sendcnt = elementSize*transferSize.col(myid).cast<\textcolor{keywordtype}{int}>();
354   Eigen::ArrayXi recvcnt = elementSize*transferSize.row(myid).cast<\textcolor{keywordtype}{int}>();
355 
356   \textcolor{comment}{// Offsets in sent messages}
357   Eigen::ArrayXi senddsp = Eigen::ArrayXi::Zero(nprocs);
358   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i < nprocs; i++)
359     senddsp(i) = sendcnt(i-1) + senddsp(i-1);
360 
361   \textcolor{comment}{// Offsets in received messages}
362   Eigen::ArrayXi recvdsp = Eigen::ArrayXi::Zero(nprocs);
363   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i < nprocs; i++)
364     recvdsp(i) = recvcnt(i-1) + recvdsp(i-1);
365 
366   \textcolor{comment}{// The Element transfer}
367   \mbox{\hyperlink{class_element}{Element}}.resize(recvcnt.sum()/elementSize, elementSize);
368   MPI\_Alltoallv(elmcpy.data(), sendcnt.data(), senddsp.data(),
369                 MPIU\_INT, \mbox{\hyperlink{class_element}{Element}}.data(), recvcnt.data(),
370                 recvdsp.data(), MPIU\_INT, comm);
371 
372   \textcolor{comment}{// Update distribution across processes}
373   elDist(myid+1) = \mbox{\hyperlink{class_element}{Element}}.rows();
374   nLocElem = \mbox{\hyperlink{class_element}{Element}}.rows();
375   MPI\_Allgather(MPI\_IN\_PLACE, 0, MPI\_DATATYPE\_NULL, elDist.data()+1,
376                 1, MPIU\_INT, comm);
377   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i <= nprocs; i++)
378     elDist(i) += elDist(i-1);
379 
380   \textcolor{comment}{// Create global permutation array after sharing Elements}
381   \textcolor{comment}{// This is currently assembling a global vector on all processes and reducing}
382   \textcolor{comment}{// it.  The performance could possibly be improved by sharing the local parts}
383   \textcolor{comment}{// and then assembling after transfer, thereby reducing communications.}
384   \textcolor{comment}{// Permute = permutation vector, permute(i) = newi}
385   \textcolor{comment}{// Indices = vector indicating where this process can start assigning Elements}
386   \textcolor{comment}{//            on each process (i.e. global locations in the permute vector)}
387   ArrayXI permute = ArrayXI::Zero(nElem);
388   ArrayXI indices = ArrayXI::Zero(nprocs);
389   indices.segment(1,nprocs-1) = transferSize.block(0, 0, nprocs-1, nprocs)
390                                 .rowwise().sum();
391   partial\_sum(indices.data(), indices.data()+nprocs, indices.data());
392   indices += transferSize.block(0, 0, nprocs, myid).rowwise().sum();
393   \textcolor{keywordtype}{int} permuteStart = transferSize.block(0, 0, nprocs, myid).sum();
394   \textcolor{keywordflow}{for} (PetscInt i = 0; i < partition.rows(); i++)
395   \{
396     permute(where(i)+permuteStart) = indices(partition(i))++;
397   \}
398   MPI\_Allreduce(MPI\_IN\_PLACE, permute.data(), nElem, MPIU\_INT, MPI\_SUM, comm);
399 
400   \textcolor{keywordflow}{return} ierr;
401 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_mesh_a1930d80c707de6d202dac7cef0022257}\label{class_mesh_a1930d80c707de6d202dac7cef0022257}} 
\index{Mesh@{Mesh}!Expand\+\_\+\+Node@{Expand\+\_\+\+Node}}
\index{Expand\+\_\+\+Node@{Expand\+\_\+\+Node}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Expand\+\_\+\+Node()}{Expand\_Node()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Expand\+\_\+\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Capture surrounding Nodes on other processes List of all the Nodes the local Elements need

Pull out already owned Nodes

Find where all those Nodes are and how many Nodes are neede from each process

Tell each process how many Nodes you need sent over

Offsets in recieved messages regarding which Nodes are requested

Get offsets in sent messages requesting Nodes

Send the Nodes you want to each process

Pack up all the Nodes for sending

Ship the Nodes

Update the global Node list 

Definition at line 482 of file mesh.\+cc.


\begin{DoxyCode}
483 \{
484   PetscErrorCode ierr = 0;
485 
487   ArrayXI ndlist = Eigen::Map<ArrayXI>(\mbox{\hyperlink{class_element}{Element}}.data(),\mbox{\hyperlink{class_element}{Element}}.size());
488   EigLab::Unique(ndlist, 1);
489 
491   PetscInt ind = 0, nind = 0;
492   \textcolor{keywordflow}{for} (PetscInt i = 0; i < ndlist.rows(); i++)
493   \{
494       \textcolor{keywordflow}{if} (ind == gNode.size())
495       \{
496           ndlist.segment(nind, ndlist.rows()-i) = ndlist.segment(i, ndlist.rows()-i);
497           nind += ndlist.rows()-i;
498           \textcolor{keywordflow}{break};
499       \}
500       \textcolor{keywordflow}{if} (gNode(ind) != ndlist(i))
501           ndlist(nind++) = ndlist(i);
502       \textcolor{keywordflow}{else}
503           ind++;
504   \}
505   ndlist.conservativeResize(nind);
506 
508   ArrayXI where( ndlist.rows() );
509   Eigen::ArrayXi perproc = Eigen::ArrayXi::Zero( nprocs );
510   \textcolor{keywordtype}{short} proc = 0;
511   \textcolor{keywordflow}{for} (PetscInt i = 0; i < ndlist.rows(); i++)
512   \{
513       \textcolor{keywordflow}{while}( ndlist(i) >= ndDist(proc+1) )
514           proc++;
515       where(i) = proc;
516       perproc(proc)++;
517   \}
518 
520   Eigen::ArrayXi sendcnt(nprocs);
521   MPI\_Alltoall(perproc.data(), 1, MPI\_INT, sendcnt.data(), 1, MPI\_INT, comm);
522 
524   Eigen::ArrayXi senddsp = Eigen::ArrayXi::Zero(nprocs);
525   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i < nprocs; i++)
526       senddsp(i) = sendcnt(i-1) + senddsp(i-1);
527 
529   Eigen::ArrayXi perprocdisp = Eigen::ArrayXi::Zero(nprocs);
530   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i < nprocs; i++)
531       perprocdisp(i) = perprocdisp(i-1)+perproc(i-1);
532 
534   ArrayXI sendnd(sendcnt.sum());
535   MPI\_Alltoallv(ndlist.data(), perproc.data(), perprocdisp.data(),
536                 MPIU\_INT, sendnd.data(), sendcnt.data(),
537                 senddsp.data(), MPIU\_INT, comm);
538 
540   ArrayXXSRM ndpack(sendcnt.sum(),nDims);
541   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < sendcnt.sum(); i++)
542       ndpack.row(i) = Node.row(sendnd(i)-ndDist(myid));
543 
545   Node.conservativeResize(nLocNode+perproc.sum(), nDims);
546   perprocdisp += nLocNode; perprocdisp *= nDims;
547   sendcnt *= nDims; senddsp *= nDims; perproc *= nDims;
548   MPI\_Alltoallv(ndpack.data(), sendcnt.data(), senddsp.data(),
549                 MPI\_DOUBLE, Node.data(), perproc.data(),
550                 perprocdisp.data(), MPI\_DOUBLE, comm);
551 
553   gNode.conservativeResize(Node.rows());
554   gNode.segment(nLocNode, ndlist.rows()) = ndlist;
555 
556   \textcolor{keywordflow}{return} ierr;
557 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_mesh_af9e180bd8adb9c495e6c38840ea19f10}\label{class_mesh_af9e180bd8adb9c495e6c38840ea19f10}} 
\index{Mesh@{Mesh}!Initialize\+\_\+\+Vectors@{Initialize\+\_\+\+Vectors}}
\index{Initialize\+\_\+\+Vectors@{Initialize\+\_\+\+Vectors}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Initialize\+\_\+\+Vectors()}{Initialize\_Vectors()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Initialize\+\_\+\+Vectors (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Set up ghost communications for P\+Et\+Sc vectors 

Definition at line 562 of file mesh.\+cc.


\begin{DoxyCode}
563 \{
564     PetscErrorCode ierr = 0;
565     \textcolor{comment}{// Nodal ghost info}
566     ArrayXXIRM ghosts( gNode.size()-nLocNode, nDims );
567     ghosts.col(0) = nDims*gNode.segment( nLocNode,gNode.size()-nLocNode );
568     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i < nDims; i++)
569       ghosts.col(i) = ghosts.col(i-1) + 1;
570 
571     ierr = VecCreateGhost(comm, nDims*nLocNode, nDims*nNode,
572                           ghosts.size(), ghosts.data(), &U); CHKERRQ(ierr);
573     ierr = VecSet(U, 0.0); CHKERRQ(ierr);
574     ierr = VecDuplicate(U, &F); CHKERRQ(ierr);
575     ierr = VecSet(F, 0.0); CHKERRQ(ierr);
576 
577     \textcolor{keywordflow}{return} ierr;
578 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_mesh_a54a12376bf99f4f4991af01fc23c9c09}\label{class_mesh_a54a12376bf99f4f4991af01fc23c9c09}} 
\index{Mesh@{Mesh}!Localize@{Localize}}
\index{Localize@{Localize}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Localize()}{Localize()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Localize (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Convert global numberings to local numberings Convert Elements to local Node numbers 

Definition at line 583 of file mesh.\+cc.


\begin{DoxyCode}
584 \{
585     PetscErrorCode ierr = 0;
586 
588     PetscInt *start = gNode.data(), *finish = gNode.data()+gNode.size();
589     \textcolor{keywordflow}{for} (PetscInt i = 0; i < \mbox{\hyperlink{class_element}{Element}}.rows(); i++)
590     \{
591         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} j = 0; j < \mbox{\hyperlink{class_element}{Element}}.cols(); j++)
592             \mbox{\hyperlink{class_element}{Element}}(i,j) = std::find(start, finish, \mbox{\hyperlink{class_element}{Element}}(i,j)) - start;
593     \}
594 
595     \textcolor{keywordflow}{return} ierr;
596 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_mesh_aa6b19f4fdf210f8937694e8c7d30ea15}\label{class_mesh_aa6b19f4fdf210f8937694e8c7d30ea15}} 
\index{Mesh@{Mesh}!Node\+Dist@{Node\+Dist}}
\index{Node\+Dist@{Node\+Dist}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Node\+Dist()}{NodeDist()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Node\+Dist (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Node Distribution Find which Nodes each process interacts with

Sort Nodes into chunks to go to each process

Package the Nodes into a new array for sending to each process And track how many are being sent to each process ~\newline
~\newline
~\newline
~\newline
~\newline
 Offsets in sent messages

Offsets in recieved messages

The Node transfer

Update the distribution of Nodes

Renumber Nodes in \mbox{\hyperlink{class_element}{Element}} array 

Definition at line 406 of file mesh.\+cc.


\begin{DoxyCode}
407 \{
408     PetscErrorCode ierr = 0;
409 
411     Eigen::Array<short,-1,1> pckproc = Eigen::Array<short,-1,1>::Zero(nNode);
412     \textcolor{keywordflow}{for} (PetscInt el = 0; el < \mbox{\hyperlink{class_element}{Element}}.rows(); el++)
413     \{
414         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} nd = 0; nd < pow(2, nDims); nd++)
415             pckproc(\mbox{\hyperlink{class_element}{Element}}(el,nd)) = myid;
416     \}
417 
418     \textcolor{comment}{// Assign Nodes to the highest numbered processor that uses them}
419     MPI\_Allreduce(MPI\_IN\_PLACE, pckproc.data(), nNode, MPI\_SHORT, MPI\_MAX, comm);
420 
422     Eigen::Array<short,-1,1> locpart = pckproc.segment(ndDist(myid),nLocNode);
423     ArrayXI reorder = EigLab::gensort(locpart).cast<PetscInt>();
426     ArrayXXSRM ndcpy(Node.rows(),Node.cols());
427     Eigen::ArrayXi sendcnt = Eigen::ArrayXi::Zero(nprocs);
428     \textcolor{keywordflow}{for} (PetscInt i = 0; i < locpart.rows(); i++)
429     \{
430         ndcpy.row(i) = Node.row(reorder(i)).transpose();
431         sendcnt(locpart(i))++;
432     \}
433 
434     \textcolor{comment}{// How much to receive from every process}
435     Eigen::ArrayXi recvcnt(nprocs);
436     MPI\_Alltoall(sendcnt.data(), 1, MPI\_INT, recvcnt.data(), 1, MPI\_INT, comm);
437 
439     Eigen::ArrayXi senddsp = Eigen::ArrayXi::Zero(nprocs);
440     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i < nprocs; i++)
441         senddsp(i) = nDims*sendcnt(i-1) + senddsp(i-1);
442 
444     Eigen::ArrayXi recvdsp = Eigen::ArrayXi::Zero(nprocs);
445     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i < nprocs; i++)
446         recvdsp(i) = nDims*recvcnt(i-1) + recvdsp(i-1);
447 
449     Node.resize(recvcnt.sum(),nDims);
450     recvcnt *= nDims; sendcnt *= nDims;
451     MPI\_Alltoallv(ndcpy.data(), sendcnt.data(), senddsp.data(),
452                   MPI\_DOUBLE, Node.data(), recvcnt.data(),
453                   recvdsp.data(), MPI\_DOUBLE, comm);
454 
456     ndDist.setZero(nprocs+1);
457     nLocNode = Node.rows();
458     ndDist(myid+1) = Node.rows();
459     MPI\_Allreduce(MPI\_IN\_PLACE, ndDist.data()+1, nprocs, MPIU\_INT, MPI\_MAX, comm);
460     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} i = 1; i <= nprocs; i++)
461         ndDist(i) += ndDist(i-1);
462 
464     reorder = EigLab::gensort(pckproc).cast<PetscInt>();
465     ArrayXI invreorder(reorder.rows());
466     \textcolor{keywordflow}{for} (PetscInt i = 0; i < reorder.rows(); i++)
467       invreorder(reorder(i)) = i;
468     \textcolor{keywordflow}{for} (PetscInt el = 0; el < \mbox{\hyperlink{class_element}{Element}}.rows(); el++)
469     \{
470         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{short} nd = 0; nd < pow(2,nDims); nd++)
471         \{
472             \mbox{\hyperlink{class_element}{Element}}(el,nd) = invreorder(\mbox{\hyperlink{class_element}{Element}}(el,nd));
473         \}
474     \}
475 
476     \textcolor{keywordflow}{return} ierr;
477 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_mesh_a69a626f34e07b13615847d2d3028f20b}\label{class_mesh_a69a626f34e07b13615847d2d3028f20b}} 
\index{Mesh@{Mesh}!Redistribute@{Redistribute}}
\index{Redistribute@{Redistribute}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Redistribute()}{Redistribute()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Redistribute (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Redistribute Elements Local \mbox{\hyperlink{class_element}{Element}} Numbering 

Definition at line 126 of file mesh.\+cc.


\begin{DoxyCode}
127 \{
128   \textcolor{keywordflow}{if} (nprocs == 1)
129     \textcolor{keywordflow}{return} 0;
130 
131   PetscErrorCode err = 0;
132   \textcolor{keywordflow}{if} (elDist(1) == elDist(nprocs))
133   \{
134     \textcolor{comment}{// Everything on processor 1, use METIS}
135     err = \mbox{\hyperlink{class_mesh_a0ab1f20471ff5deed8803597b979779d}{ReorderMETIS}}(); CHKERRQ(err);
136   \}
137   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((elDist.segment(1, nprocs) - elDist.segment(0, nprocs)).minCoeff() == 0)
138   \{
139     \textcolor{comment}{// Some processors are empty, ParMETIS will fail}
140     err = MPI\_Abort(comm, 404);
141   \}
142   \textcolor{keywordflow}{else}
143   \{
144     \textcolor{comment}{// We can use ParMETIS}
145     err = \mbox{\hyperlink{class_mesh_ab9c61b0cf7cbcb8738d0e904fe532e91}{ReorderParMETIS}}(); CHKERRQ(err);
146   \}
147 
148   err = \mbox{\hyperlink{class_mesh_aa6b19f4fdf210f8937694e8c7d30ea15}{NodeDist}}(); CHKERRQ(err);
149   gElem = ArrayXI::LinSpaced(this->nLocElem, elDist(myid), elDist(myid+1)-1);
150   gNode = ArrayXI::LinSpaced(this->nLocNode, ndDist(myid), ndDist(myid+1)-1);
151   err = \mbox{\hyperlink{class_mesh_a1930d80c707de6d202dac7cef0022257}{Expand\_Node}}(); CHKERRQ(err);
152   err = \mbox{\hyperlink{class_mesh_af9e180bd8adb9c495e6c38840ea19f10}{Initialize\_Vectors}}(); CHKERRQ(err);
153 
155   err = \mbox{\hyperlink{class_mesh_a54a12376bf99f4f4991af01fc23c9c09}{Localize}}(); CHKERRQ(err);
156 
157   \textcolor{keywordflow}{return} err;
158 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_mesh_a0ab1f20471ff5deed8803597b979779d}\label{class_mesh_a0ab1f20471ff5deed8803597b979779d}} 
\index{Mesh@{Mesh}!Reorder\+M\+E\+T\+IS@{Reorder\+M\+E\+T\+IS}}
\index{Reorder\+M\+E\+T\+IS@{Reorder\+M\+E\+T\+IS}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Reorder\+M\+E\+T\+I\+S()}{ReorderMETIS()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Reorder\+M\+E\+T\+IS (\begin{DoxyParamCaption}\item[{Petsc\+Int}]{nparts = {\ttfamily 0},  }\item[{Petsc\+Int}]{n\+Common\+Nodes = {\ttfamily 0},  }\item[{Petsc\+Scalar $\ast$}]{tpwgts = {\ttfamily NULL},  }\item[{Petsc\+Int $\ast$}]{elmwgt = {\ttfamily NULL},  }\item[{Petsc\+Int $\ast$}]{opts = {\ttfamily NULL} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Get element partitioning in serial 

Definition at line 163 of file mesh.\+cc.


\begin{DoxyCode}
166 \{
167   PetscErrorCode err = 0;
168   ArrayXI ePart = ArrayXI::Ones(nLocElem);
169   ArrayXI nPart = ArrayXI::Ones(nLocNode);
170 
171   \textcolor{keywordflow}{if} (myid == 0)
172   \{
173     ArrayXI eptr = ArrayXI::LinSpaced(nElem+1, 0, \mbox{\hyperlink{class_element}{Element}}.size());
174 
175     \textcolor{comment}{// Verify Inputs}
176     \textcolor{keywordflow}{if} (nparts <= 0)
177       nparts = nprocs;
178     \textcolor{keywordflow}{if} (nCommonNodes <= 0)
179       nCommonNodes = pow(2, nDims-1);
180 
181     \textcolor{comment}{/*if (opts == NULL)                         //0 for default options}
182 \textcolor{comment}{    \{ opts = new PetscInt; opts[0] = 0;\}*/}
183 
184     real\_t *tpwgts\_r;
185     \textcolor{keywordflow}{if} (tpwgts == NULL)                \textcolor{comment}{//Vertex weight in each subdomain}
186     \{
187       tpwgts\_r = \textcolor{keyword}{new} real\_t[nparts];
188       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < nparts; i++)
189       \{
190         tpwgts\_r[i] = 1.0/nparts;
191       \}
192     \}
193     \textcolor{keywordflow}{else}
194     \{
195       tpwgts\_r = \textcolor{keyword}{new} real\_t[nparts];
196       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < nparts; i++)
197       \{
198         tpwgts\_r[i] = tpwgts[i];
199       \}
200     \}
201 
202     \textcolor{comment}{// Call METIS}
203     PetscInt METIS, edgecut;
204     \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(idx\_t) != \textcolor{keyword}{sizeof}(PetscInt))
205     \{
206       cout << \textcolor{stringliteral}{"WARNING, PetscInt and ParMETIS int (PetscInt) are of different "} <<
207               \textcolor{stringliteral}{"sizes, skipping reordering with ParMETIS.\(\backslash\)n"};
208       METIS = METIS\_OK;
209     \}
210     \textcolor{keywordflow}{else}
211       METIS = METIS\_PartMeshDual(&nElem, &nNode, eptr.data(),
212               \mbox{\hyperlink{class_element}{Element}}.data(), elmwgt, NULL, &nCommonNodes, &nparts,
213           tpwgts\_r, opts, &edgecut, ePart.data(), nPart.data());
214 
215     \textcolor{keyword}{delete}[] tpwgts\_r;
216     \textcolor{comment}{//delete opts;}
217 
218     \textcolor{keywordflow}{if} (METIS != METIS\_OK)
219     \{
220       std::cerr << \textcolor{stringliteral}{"Error partitioning matrix! Error code: "} << METIS << \textcolor{stringliteral}{"\(\backslash\)n"};
221       \textcolor{keywordflow}{return} METIS;
222     \}
223   \}
224 
225   err = \mbox{\hyperlink{class_mesh_a1c915802d56c4ded24e460e83cfb5399}{ElemDist}}(ePart);
226 
227   \textcolor{keywordflow}{return} err;
228 \}
\end{DoxyCode}
\mbox{\Hypertarget{class_mesh_ab9c61b0cf7cbcb8738d0e904fe532e91}\label{class_mesh_ab9c61b0cf7cbcb8738d0e904fe532e91}} 
\index{Mesh@{Mesh}!Reorder\+Par\+M\+E\+T\+IS@{Reorder\+Par\+M\+E\+T\+IS}}
\index{Reorder\+Par\+M\+E\+T\+IS@{Reorder\+Par\+M\+E\+T\+IS}!Mesh@{Mesh}}
\subsubsection{\texorpdfstring{Reorder\+Par\+M\+E\+T\+I\+S()}{ReorderParMETIS()}}
{\footnotesize\ttfamily Petsc\+Error\+Code Mesh\+::\+Reorder\+Par\+M\+E\+T\+IS (\begin{DoxyParamCaption}\item[{Petsc\+Int}]{nparts = {\ttfamily 0},  }\item[{Petsc\+Int}]{n\+Common\+Nodes = {\ttfamily 0},  }\item[{Petsc\+Scalar $\ast$}]{tpwgts = {\ttfamily NULL},  }\item[{Petsc\+Scalar $\ast$}]{ubvec = {\ttfamily NULL},  }\item[{Petsc\+Int $\ast$}]{opts = {\ttfamily NULL},  }\item[{Petsc\+Int}]{ncon = {\ttfamily 1},  }\item[{Petsc\+Int $\ast$}]{elmwgt = {\ttfamily NULL},  }\item[{Petsc\+Int}]{wgtflag = {\ttfamily 0},  }\item[{Petsc\+Int}]{numflag = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Get element partitioning in parallel Verify Inputs

Initialize Par\+M\+E\+T\+IS Variables 

Definition at line 233 of file mesh.\+cc.


\begin{DoxyCode}
236 \{
237   PetscErrorCode err = 0;
238 
240   \textcolor{keywordflow}{if} (nparts <= 0)
241     nparts = nprocs;
242   \textcolor{keywordflow}{if} (nCommonNodes <= 0)
243     nCommonNodes = pow(2, nDims-1);
244 
245   \textcolor{comment}{// Local Element Descriptions - Element contains the Nodes,}
246   \textcolor{comment}{// eptr specifies where each Element starts}
247   \textcolor{keywordtype}{short} elementSize = pow(2,nDims);
248   Eigen::Array<PetscInt, -1, -1> eptr =
249     Eigen::Array<PetscInt, -1, 1>::LinSpaced(nLocElem+1,0,nLocElem*elementSize);
250   Eigen::Array<PetscInt, -1, 1> partition = myid*Eigen::Array<PetscInt, -1, 1>::Ones(nLocElem);
251 
253   real\_t *ubvec\_r;
254   \textcolor{keywordflow}{if} (ubvec == NULL)                            \textcolor{comment}{//Imbalance tolerance}
255   \{
256     ubvec\_r = \textcolor{keyword}{new} real\_t[ncon];
257     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < ncon; i++)
258       ubvec\_r[i] = 1.05+(\textcolor{keywordtype}{double})nparts/nElem;
259   \}
260   \textcolor{keywordflow}{else}
261   \{
262     ubvec\_r = \textcolor{keyword}{new} real\_t[ncon];
263     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < ncon; i++)
264       ubvec\_r[i] = ubvec[i];
265   \}
266 
267   idx\_t *opts\_r;
268   \textcolor{keywordflow}{if} (opts == NULL)                         \textcolor{comment}{//0 for default options}
269   \{ opts\_r = \textcolor{keyword}{new} PetscInt; opts\_r[0] = 0; \}
270   \textcolor{keywordflow}{else}
271   \{ opts\_r = \textcolor{keyword}{new} PetscInt; opts\_r[0] = opts[0]; \}
272 
273   real\_t *tpwgts\_r;
274   \textcolor{keywordflow}{if} (tpwgts == NULL)                \textcolor{comment}{//Vertex weight in each subdomain}
275   \{
276     tpwgts\_r = \textcolor{keyword}{new} real\_t[ncon*nparts];
277     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < nparts; i++)
278     \{
279       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < ncon; j++)
280         tpwgts\_r[i*ncon+j] = 1.0/nparts;
281     \}
282   \}
283   \textcolor{keywordflow}{else}
284   \{
285     tpwgts\_r = \textcolor{keyword}{new} real\_t[ncon*nparts];
286     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < nparts; i++)
287     \{
288       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < ncon; j++)
289         tpwgts\_r[i*ncon+j] = tpwgts[i*ncon+j];
290     \}
291   \}
292 
293   PetscInt edgecut;
294 
295   \textcolor{comment}{// Call ParMETIS}
296   PetscInt METIS;
297   \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(idx\_t) != \textcolor{keyword}{sizeof}(PetscInt))
298   \{
299     cout << \textcolor{stringliteral}{"WARNING, PetscInt and ParMETIS int (PetscInt) are of different "} <<
300             \textcolor{stringliteral}{"sizes, skipping reordering with ParMETIS.\(\backslash\)n"};
301     partition.setConstant(myid); METIS = METIS\_OK;
302   \}
303   \textcolor{keywordflow}{else}
304     METIS = ParMETIS\_V3\_PartMeshKway(elDist.data(), eptr.data(),
305             \mbox{\hyperlink{class_element}{Element}}.data(), elmwgt, &wgtflag, &numflag, &ncon,
306             &nCommonNodes, &nparts, tpwgts\_r, ubvec\_r, opts\_r,
307             &edgecut, partition.data(), &comm);
308   
309   \textcolor{keyword}{delete}[] ubvec\_r;
310   \textcolor{keyword}{delete}[] tpwgts\_r;
311   \textcolor{keyword}{delete} opts\_r;
312 
313   \textcolor{keywordflow}{if} (METIS != METIS\_OK)
314   \{
315     std::cerr << \textcolor{stringliteral}{"Error partitioning matrix! Error code: "} << METIS << \textcolor{stringliteral}{"\(\backslash\)n"};
316     \textcolor{keywordflow}{return} METIS;
317   \}
318 
319   err = \mbox{\hyperlink{class_mesh_a1c915802d56c4ded24e460e83cfb5399}{ElemDist}}(partition);
320 
321   \textcolor{keywordflow}{return} err;
322 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/mesh.\+h\item 
src/mesh.\+cc\end{DoxyCompactItemize}
